Intuition

The N-Queens problem asks how many ways we can place n queens on an nÃ—n chessboard such that no two queens attack each other.
A queen can attack another piece if they are in the same row, column, or diagonal.
The intuitive idea is to place one queen per row and recursively try to place queens in the next rows while ensuring that each placement is safe.

Approach

We use backtracking:

Start from the first row (i = 0) and try placing a queen in each column.

For each attempted position (i, j), check if itâ€™s safe using the issafe() function â€” meaning no other queen exists in the same column or diagonals above the current row.

If itâ€™s safe, recursively move to the next row.

If we reach beyond the last row (i == n), we found a valid arrangement and add it to our list of solutions.

Backtrack â€” remove the queen and try the next column.

Finally, return the count of valid configurations.

This ensures all possible configurations are explored systematically while pruning invalid paths early.

Complexity

Time complexity:

ğ‘‚(ğ‘›!)
O(n!) â€” Each queen has up to n choices, but the valid positions reduce drastically as queens are placed. Still, in the worst case, itâ€™s factorial growth.

Space complexity:

ğ‘‚(ğ‘›*n)
O(n*n) â€” For the board and recursive call stack depth of O(n).

Code
class Solution:
    def totalNQueens(self, n: int) -> int:
        def issafe(board, i, j):
            a, b = i, j
            # Check upper-left diagonal
            while a > 0 and b > 0:
                a -= 1
                b -= 1
                if board[a][b] == 'Q':
                    return False
            a, b = i, j
            # Check upper column
            while a > 0:
                a -= 1
                if board[a][b] == 'Q':
                    return False
            a, b = i, j
            # Check upper-right diagonal
            while a > 0 and b < n - 1:
                a -= 1
                b += 1
                if board[a][b] == 'Q':
                    return False
            return True

        def hel(n, ans, board, i=0):
            if i >= n:
                ans.append([''.join(x) for x in board])
                return
            for j in range(n):
                board[i][j] = 'Q'
                if issafe(board, i, j):
                    hel(n, ans, board, i + 1)
                board[i][j] = '.'

        board = [['.' for _ in range(n)] for _ in range(n)]
        ans = []
        hel(n, ans, board)
        return len(ans)